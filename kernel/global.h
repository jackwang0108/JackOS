#ifndef __KERNEL_GLOBAL_H
#define __KERNEL_GLOBAL_H

#include "stdint.h"

/* =========================================================================================================== */
/* ===========================================  构建 GDT ===================================================== */
/* =========================================================================================================== */

// 段描述符结构，上面的是高4字节，下面的是低4字节，给出的偏移都是相对4字节的，所以高4字节的偏移需要加32
// => 高4字节
/*  Offset: 31          24 22   22  21   20  19              16 15 14     13 12  11       8 7          0       */
/*          ---------------------------------------------------------------------------------------------      */
/*  Field:  | Base 31:24 | G | D/B | L | AVL | SegLimit 19:16 | P | DPL 1:0 | S | Type 3:0 | Base 23:16 |      */
/*          ---------------------------------------------------------------------------------------------      */
// => 低4字节
/*  Offset: 31                                           16 15                                         0       */
/*          ---------------------------------------------------------------------------------------------      */
/*  Field:  |              Base Address 15:00              |             Segment Limit 15:00            |      */
/*          ---------------------------------------------------------------------------------------------      */

// Base Addr        (16~31, 32~39, 56~63)    : 基地址
// Segment Limit    (0~15, 48~51)            : 单元数，单位要么是1B (2^20*1B=1MB), 要么是4KB(2^20*4KB=4GB).
// G                (54)                     : G=1则段界限单位为4KB; G=0则段界限单位大小为1B
// S                (44)                     : S=0则当前段为系统段(门); S=1则当前段为数据段. 操作系统、代码等等都被视为是数据段
// Type             (40~44)                  : S=0时Type表示是中断门、调用门、陷阱门中的哪一种; S=1时Type表示段的读写执行属性
// DPL              (45~46)                  : 当前描述符的特全局 (Descriptor Privilege Level), 00 > 01 > 10 > 11
// P                (47)                     : 段存在于内存中则P=1, 否则P=0
// AVL              (52)                     : 段是否是可用的。不过这可用是对用户来说的，操作系统可以随意用此位
// L                (53)                     : L=1表示当前段为64位代码段，否则表示32位代码段
// D/B              (54)                     : D/B=1表示当前段为32位, 所用指令和数据都是32位. D/B=0表示是16位


/* ------------------------------ 段描述符属性 ------------------------------ */
#define DESC_G_4K       1           // 短界限粒度为4K
#define DESC_D_32       1           // 指定指令中的地址和操作数都是32位
#define DESC_L          0           // 指定是32位代码段
#define DESC_AVL        0           // 对CPU无用，留空即可
#define DESC_P          1           // 段的存在位
#define DESC_DPL_0      0           // Descriptor Privilege Level 0
#define DESC_DPL_1      1           // Descriptor Privilege Level 1
#define DESC_DPL_2      2           // Descriptor Privilege Level 2
#define DESC_DPL_3      3           // Descriptor Privilege Level 3
#define DESC_S_CODE     1           //
#define DESC_S_DATA     DESC_S_CODE //
#define DESC_S_SYS      0           // 系统段
#define DESC_TYPE_CODE  0b1000      // 数据段中的代码段, XCRA, 可执行
#define DESC_TYPE_DATA  0b0010      // 数据段中的数据段, XEWA, 可写的
#define DESC_TYPE_TSS   0b1001      // 系统段中的TSS段, 表示当前段是80386的TSS段, 10B1, B=1表示当前TSS段正忙


/* ----------------------------- 一般段描述符属性 ----------------------------- */
// 八字节段描述符中第七个字节中的属性（高字节处）
#define GDT_ATTR_HIGH               ((DESC_G_4K << 7) + (DESC_D_32 << 6) + (DESC_L << 5) + (DESC_AVL << 4))
// 八字节段描述符中第六个字节中的属性（低字节处）
#define GDT_CODE_ATTR_LOW_DPL3      ((DESC_P << 7) + (DESC_DPL_3 << 5) + (DESC_S_CODE << 4) + DESC_TYPE_CODE)       // 用户代码段
#define GDT_DATA_ATTR_LOW_DPL3      ((DESC_P << 7) + (DESC_DPL_3 << 5) + (DESC_S_DATA << 4) + DESC_TYPE_DATA)       // 用户数据段


/* ----------------------------- TSS描述符属性 ----------------------------- */
#define TSS_DESC_D      0
#define TSS_ATTR_HIGH   ((DESC_G_4K << 7) + (TSS_DESC_D << 6) + (DESC_L << 5) + (DESC_AVL << 4) + 0x0)
#define TSS_ATTR_LOW    ((DESC_P << 7) + (DESC_DPL_3 << 5) + (DESC_S_SYS << 4) + DESC_TYPE_TSS)


/* ------------------------------ 段选择子属性 ------------------------------ */
#define RPL0 0                      // 段描述符的权限，即RPL
#define RPL1 1                      // 段描述符的权限，即RPL
#define RPL2 2                      // 段描述符的权限，即RPL
#define RPL3 3                      // 段描述符的权限，即RPL
#define TI_GDT 0                    // 段选择子TI位，TI=0在GDT中，TI=1在LDT中
#define TI_LDT 1                    // 段选择子TI位，TI=0在GDT中，TI=1在LDT中


/* ------------------------------ 构建段选择子 ------------------------------ */
// => 内核段选择子
#define SELECTOR_K_CODE     ((1 << 3) + (TI_GDT << 2) + RPL0)           // 指向内核代码段
#define SELECTOR_K_DATA     ((2 << 3) + (TI_GDT << 2) + RPL0)           // 指向内核数据段
#define SELECTOR_K_STACK    SELECTOR_K_DATA                             // 指向内核代码段
#define SELECTOR_K_GS       ((3 << 3) + (TI_GDT << 2) + RPL0)           // 指向内核视频段，指向显存
// => TSS段选择子
#define SELECTOR_TSS        ((4 << 3) + (TI_GDT << 2) + RPL0)           // 指向TSS段
// => 用户段选择子
#define SELECTOR_U_CODE     ((5 << 3) + (TI_GDT << 2) + RPL3)           // 指向用户代码段
#define SELECTOR_U_DATA     ((6 << 3) + (TI_GDT << 2) + RPL3)           // 指向用户数据段
#define SELECTOR_U_STACK    SELECTOR_U_DATA                             // 指向用户数据段
// PS: 32位保护模式下，每个段选择子16位，一个uint16_t


// GDT中的段描述符的结构
// GDT中的段描述符可能是:
//      1. 一般段描述符
//      2. 特殊段描述符:
//              2.1 TSS段描述符
typedef struct __gdt_desc_t {
    uint16_t limit_low_word;
    uint16_t base_low_word;
    uint8_t base_mid_byte;
    uint8_t attr_low_byte;
    uint8_t limit_high_attr_high;
    uint8_t bsae_high_byte;
} gdt_desc_t;


/* =========================================================================================================== */
/* ===========================================  构建 GDT ===================================================== */
/* =========================================================================================================== */



/* =========================================================================================================== */
/* ===========================================  构建 IDT ===================================================== */
/* =========================================================================================================== */

// 中断描述符属性
#define IDT_DESC_P          1
#define IDT_DESC_RPL0       0
#define IDT_DESC_RPL3       3
#define IDT_DESC_32_TYPE    0xE                 // 32位中断门
#define IDT_DESC_16_TYPE    0x6                 // 16位中断门，实际上不会调用

// 中断描述符，32位保护模式下，每个中断描述符32位位，一个int
#define IDT_DESC_ATTR_DPL0  ((IDT_DESC_P << 7) + (IDT_DESC_RPL0 << 5) + IDT_DESC_32_TYPE)
#define IDT_DESC_ATTR_DPL3  ((IDT_DESC_P << 7) + (IDT_DESC_RPL3 << 5) + IDT_DESC_32_TYPE)


/* =========================================================================================================== */
/* ===========================================  构建 IDT ===================================================== */
/* =========================================================================================================== */




/* =========================================================================================================== */
/* ==========================================  创建用户进程 ==================================================== */
/* =========================================================================================================== */


// EFLAGS寄存器
/*  Offset: 31          22  21   20    19    18   17   16  15   14  13      12  11   10   9    8    6    5   4    3   2    1   0     */
/*          -----------------------------------------------------------------------------------------------------------------------  */
/*  Field:  |    保留项    | ID | VIP | VIF | AC | VM | RF | 0 | NT | TOPL 1:0 | OF | DF | IF | TF | SF | 0 | AF | 0 | PF | 1 | CF |  */
/*          -----------------------------------------------------------------------------------------------------------------------  */


#define EFLAGS_MBS      (1 << 1)            // 保留项，必须为1
#define EFLAGS_IF_1     (1 << 9)
#define EFLAGS_IF_0     0
#define EFLAGS_IOPL_0   (0b00 << 12)
#define EFLAGS_IOPL_3   (0b11 << 12)


/* =========================================================================================================== */
/* ==========================================  创建用户进程 ==================================================== */
/* =========================================================================================================== */


// 常用的定义
#define bool int
#define NULL ((void *) 0)
#define true 1
#define false 0

// 一个页4096个字节，即4K
#define PG_SIZE 4096

// 向上整除
#define DIV_CEILING(X, STEP) ((X + STEP - 1) / (STEP))

#define UNUSED __attribute__((unused))

#endif